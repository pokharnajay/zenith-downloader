import * as fs from 'fs';
import * as path from 'path';
import { TEMP_CHROMIUM_DIR, incrementChromiumUsage } from './cookieManagerV2';

// Puppeteer will be dynamically imported to avoid bundling issues
type Browser = any;
type Page = any;

/**
 * Warm up a browser session and extract cookies
 */
export async function warmupSessionAndGetCookies(videoUrl: string): Promise<{
  success: boolean;
  cookiePath?: string;
  error?: string;
}> {
  let browser: Browser | null = null;

  try {
    console.log('[ChromiumWarmer] Starting browser warm-up for:', videoUrl);

    // Dynamic import of puppeteer (only when needed)
    const puppeteer = await import('puppeteer').catch(() => null);

    if (!puppeteer) {
      return {
        success: false,
        error: 'Puppeteer not installed. Run: npm install puppeteer',
      };
    }

    // Launch headless Chromium with stealth settings
    browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-web-security',
        '--disable-features=IsolateOrigins,site-per-process',
        '--disable-blink-features=AutomationControlled',
        '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      ],
      executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || undefined,
    });

    const page: Page = await browser.newPage();

    // Set realistic viewport
    await page.setViewport({
      width: 1920,
      height: 1080,
      deviceScaleFactor: 1,
    });

    // Additional stealth measures
    await page.evaluateOnNewDocument(() => {
      // Override navigator properties
      Object.defineProperty(navigator, 'webdriver', {
        get: () => false,
      });

      // Mock plugins
      Object.defineProperty(navigator, 'plugins', {
        get: () => [1, 2, 3, 4, 5],
      });

      // Mock languages
      Object.defineProperty(navigator, 'languages', {
        get: () => ['en-US', 'en'],
      });
    });

    console.log('[ChromiumWarmer] Loading YouTube page...');

    // Load the YouTube video page
    await page.goto(videoUrl, {
      waitUntil: 'networkidle2',
      timeout: 10000,
    });

    // Random wait time (700ms - 2000ms) to simulate human behavior
    const minWait = parseInt(process.env.CHROMIUM_WARMUP_MIN_WAIT || '700', 10);
    const maxWait = parseInt(process.env.CHROMIUM_WARMUP_MAX_WAIT || '2000', 10);
    const waitTime = minWait + Math.random() * (maxWait - minWait);

    console.log(`[ChromiumWarmer] Waiting ${Math.round(waitTime)}ms to simulate human...`);
    await new Promise(resolve => setTimeout(resolve, waitTime));

    // Scroll page a bit (human-like behavior)
    await page.evaluate(() => {
      window.scrollBy(0, 100 + Math.random() * 200);
    });

    // Wait a bit more
    await new Promise(resolve => setTimeout(resolve, 300));

    // Extract cookies from the page
    const cookies = await page.cookies();

    if (cookies.length === 0) {
      return {
        success: false,
        error: 'No cookies extracted from page',
      };
    }

    console.log(`[ChromiumWarmer] Extracted ${cookies.length} cookies`);

    // Convert to Netscape format
    const netscapeCookies = convertToNetscapeFormat(cookies);

    // Ensure temp directory exists
    if (!fs.existsSync(TEMP_CHROMIUM_DIR)) {
      fs.mkdirSync(TEMP_CHROMIUM_DIR, { recursive: true });
    }

    // Save to temporary file
    const timestamp = Date.now();
    const tempCookiePath = path.join(TEMP_CHROMIUM_DIR, `chromium_${timestamp}.txt`);

    fs.writeFileSync(tempCookiePath, netscapeCookies, { encoding: 'utf-8', mode: 0o644 });

    console.log(`[ChromiumWarmer] Saved cookies to: ${tempCookiePath}`);

    // Increment usage counter
    incrementChromiumUsage();

    return { success: true, cookiePath: tempCookiePath };

  } catch (error: any) {
    console.error('[ChromiumWarmer] Error:', error);

    return {
      success: false,
      error: error.message || 'Unknown error during browser warm-up',
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('[ChromiumWarmer] Browser closed');
      } catch (e) {
        console.error('[ChromiumWarmer] Error closing browser:', e);
      }
    }
  }
}

/**
 * Convert Puppeteer cookies to Netscape format
 */
function convertToNetscapeFormat(cookies: any[]): string {
  let output = '# Netscape HTTP Cookie File\n';
  output += '# This file was generated by Youtube Downloader Chromium Warmer\n';
  output += '# Edit at your own risk.\n\n';

  for (const cookie of cookies) {
    // Netscape format:
    // domain \t flag \t path \t secure \t expiration \t name \t value

    const domain = cookie.domain.startsWith('.') ? cookie.domain : '.' + cookie.domain;
    const flag = 'TRUE'; // HttpOnly flag
    const path = cookie.path || '/';
    const secure = cookie.secure ? 'TRUE' : 'FALSE';
    const expiration = cookie.expires ? Math.floor(cookie.expires) : '0';
    const name = cookie.name;
    const value = cookie.value;

    const line = [domain, flag, path, secure, expiration, name, value].join('\t');
    output += line + '\n';
  }

  return output;
}

/**
 * Clean up old temporary Chromium cookies
 */
export async function cleanupOldChromiumCookies(maxAgeMs: number = 3600000): Promise<void> {
  try {
    if (!fs.existsSync(TEMP_CHROMIUM_DIR)) return;

    const files = fs.readdirSync(TEMP_CHROMIUM_DIR);
    const now = Date.now();
    let cleaned = 0;

    for (const file of files) {
      if (!file.startsWith('chromium_')) continue;

      const filepath = path.join(TEMP_CHROMIUM_DIR, file);
      const stats = fs.statSync(filepath);
      const age = now - stats.mtime.getTime();

      if (age > maxAgeMs) {
        fs.unlinkSync(filepath);
        cleaned++;
      }
    }

    if (cleaned > 0) {
      console.log(`[ChromiumWarmer] Cleaned up ${cleaned} old temporary cookies`);
    }
  } catch (error) {
    console.error('[ChromiumWarmer] Error during cleanup:', error);
  }
}

/**
 * Check if Puppeteer is available
 */
export async function isPuppeteerAvailable(): Promise<boolean> {
  try {
    const puppeteer = await import('puppeteer').catch(() => null);
    return puppeteer !== null;
  } catch {
    return false;
  }
}
